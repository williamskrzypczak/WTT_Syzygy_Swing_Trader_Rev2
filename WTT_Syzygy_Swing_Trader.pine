//@version=5
indicator("WTT_Syzygy_Swing_Trader_Rev1.49", overlay=true)


// =============================================================================
// WTT SYZYGY SWING TRADER - REVISION HISTORY
// =============================================================================

// R1.56: LABEL SIZE OPTIMIZATION - SMALLER PT/SL/TS LABELS
// =========================================================
// Reduced label sizes for better visual clarity and reduced chart clutter. Changed 
// all profit target (PT), stop loss (SL), and trailing stop (TS) labels from 
// size.normal to size.small. This includes both the persistent labels on active 
// trades and the hit documentation labels. Smaller labels provide cleaner chart 
// appearance while maintaining readability and reducing visual interference with 
// price action analysis.

// R1.55: CONSERVATIVE PROFIT OPTIMIZATION - DEFAULT SETTINGS UPDATED
// ================================================================
// Optimized default settings for maximum profitability using conservative approach. 
// Reduced lookback period from 7 to 6 for more trading signals. Increased volume 
// filter threshold from 0.0 to 0.5 for stronger breakout confirmation. Enhanced 
// partial profit taking: ratio changed from 1.0 to 0.75 (earlier profit taking) 
// and size increased from 50% to 60% (more profit secured). Improved trailing 
// stop settings: activation moved from 0.5 to 0.75 R:R (later activation) and 
// distance tightened from 0.5 to 0.3 R:R (tighter stops). These optimizations 
// balance signal frequency with quality while maximizing profit capture.

// R1.54: PROFIT FACTOR TRACKING ADDED TO HUD
// ===========================================
// Added comprehensive profit factor tracking to monitor long-term strategy profitability. 
// Implemented total_profits and total_losses variables to calculate profit factor 
// (total profits / total losses). Profit factor now displays in HUD alongside success 
// rate, providing key metric for strategy evaluation. Profit factor > 1.0 indicates 
// profitable strategy, with higher values showing stronger performance. This enables 
// real-time monitoring of strategy profitability and risk-adjusted returns.

// R1.53: SUCCESS RATE CALCULATION COMPLETE FIX - PROPER TRADE TRACKING
// ====================================================================
// Fixed critical success rate calculation issue where rate could exceed 100%. 
// Added failed_trades counter to properly track swing line cross-back invalidations. 
// Updated success rate formula to use (successful_trades / total_completed_trades) 
// instead of (successful_trades / total_breaches). Now properly distinguishes 
// between successful exits (profit target, stop loss, trailing stop) and failed 
// exits (swing line cross-back). This provides accurate success rate that cannot 
// exceed 100% and reflects true system performance.

// R1.52: SUCCESS RATE CALCULATION FIX - ALL EXIT TYPES INCLUDED
// ============================================================
// Fixed success rate calculation to properly account for all exit types. Added 
// stop loss hits to success rate tracking - now ALL exits (profit target, stop 
// loss, trailing stop) count as successful trades. Only swing line cross-back 
// invalidations count as failed trades. Updated profit/risk tracking for stop 
// loss exits with zero profit and full risk calculation. This provides accurate 
// success rate reflecting proper risk management execution.

// R1.51: PROFIT TARGET HIT VISUAL DOCUMENTATION SYSTEM
// ====================================================
// Implemented comprehensive profit target hit documentation system with color-coded 
// visual elements that only display when profit targets are actually reached. Added 
// horizontal lines, information labels, and cleanup logic to show only the most 
// current profit target hit. Color-coded system uses bright green for LONG profit 
// targets and magenta for SHORT profit targets with black text for optimal readability. 
// System only documents successful profit target hits, not failed trades that hit 
// stop loss first, maintaining clean chart appearance.

// R1.50: SWING LINE CROSS-BACK INVALIDATION & ENHANCED COLOR SCHEME
// ================================================================
// Implemented fourth condition for profit target and stop loss line removal when 
// price crosses back over the original swing line, invalidating the breakout setup. 
// Enhanced color scheme with strong green (RGB: 0,200,0) for profit targets and 
// strong red (RGB: 220,0,0) for stop losses with white text for better contrast. 
// Fixed logic to only trigger on actual crossing events rather than position, 
// ensuring lines persist until proper invalidation occurs.

// R1.49: ATR DISPLAY ENHANCEMENT IN HUD TABLE
// ===========================================
// Added real-time ATR value display to the Entry & Distance row in the HUD table 
// for enhanced market context. The ATR value is shown in pips alongside the entry 
// price and distance information, providing immediate visibility into current market 
// volatility. This helps traders understand how the ATR-based profit targets and 
// stop losses are adapting to current market conditions.

// R1.48: ATR-BASED PROFIT TARGETS & STOP LOSSES WITH PRICE LABELS
// ===============================================================
// Implemented comprehensive ATR-based profit target and stop loss calculations 
// replacing the previous 1:1 risk-reward system. Added price text to all swing 
// point labels, profit target labels, stop loss labels, and trailing stop labels 
// for enhanced visibility. Profit targets now use 2 ATR while stop losses use 
// 1 ATR, creating a dynamic volatility-adaptive system that automatically adjusts 
// to market conditions. All labels now display precise price levels with improved 
// text sizing and contrast for better readability.

// R1.47: HUD SIGNAL PERSISTENCE DATA SOURCE FIX
// ==============================================
// Fixed issue where persistent display variables were only updated in alert 
// conditions, not in main breakout detection logic.

// R1.46: HUD SIGNAL PERSISTENCE LOGIC CORRECTION
// ===============================================
// Corrected logic to only clear persistent display when new signals fire, not 
// when new swing points are detected.

// R1.45: HUD SIGNAL PERSISTENCE ENHANCEMENT
// ==========================================
// Implemented persistent signal and risk-reward ratio display in HUD table to 
// maintain visibility until new signal fires.

// R1.44: RSI DOT SIZE ENHANCEMENT
// ===============================
// Enhanced visibility of RSI extreme condition dots by increasing size from tiny 
// to small.

// R1.43: CODE CLEANUP AND OPTIMIZATION
// ====================================
// Streamlined codebase by removing unused and redundant code elements to improve 
// performance.

// R1.42: HUD TABLE SPACING ENHANCEMENT
// ====================================
// Added visual spacing above HUD table to improve chart readability and reduce 
// visual clutter.

// R1.41: TABLE SIGNAL SYNCHRONIZATION WITH FILTERED ALERTS
// =======================================================
// Synchronized HUD table to only display when alerts fire with all filtering 
// conditions met.

// R1.40: RSI COLOR ENHANCEMENT & TRADING INTUITION
// ================================================
// Enhanced RSI color coding system with intuitive trading signals using different 
// shades of green and red for better visual distinction and trading decision-making.

// R1.39: RSI FILTER INTEGRATION & ENHANCED ALERT SYSTEM
// =====================================================
// Implemented comprehensive RSI filtering system for breakout alerts to improve 
// signal quality and reduce false breakouts during extreme market conditions.

// R1.38: VOLUME FILTER THRESHOLD DISPLAY ENHANCEMENT
// ==================================================
// Enhanced volume and filter row to display current threshold setting alongside 
// filter status for better user visibility.

// R1.37: RSI INTEGRATION & ENHANCED TECHNICAL ANALYSIS
// ===================================================
// Added comprehensive RSI integration to HUD table with configurable parameters 
// and color-coded status indicators.

// R1.36: TABLE CONSOLIDATION & OPTIMIZATION
// =========================================
// Streamlined risk-reward table by consolidating related information into fewer rows. 
// Reduced table size while maintaining all essential information.

// R1.35: VOLUME FILTER VALIDATION FIX
// ===================================
// Fixed critical bug in volume filtering logic where alerts weren't properly 
// respecting threshold settings.

// R1.34: STREAMLINED VOLUME ALERTS
// =================================
// Removed standalone volume alerts to eliminate redundancy with integrated volume 
// filtering system.

// R1.33: VOLUME FILTER FOR BREAKOUTS
// ==================================
// Implemented optional volume filtering system for swing breakouts with configurable 
// threshold. Added visual feedback in risk-reward table.

// R1.32: VOLUME ALERT SYSTEM IMPLEMENTATION
// =========================================
// Added comprehensive volume alert system for high and low volume detection with 
// detailed market context information.

// R1.31: TRAILING STOP ALERT ENHANCEMENT & VOLUME CALCULATION IMPROVEMENT
// ======================================================================
// Enhanced trailing stop alert with position management suggestions. Improved volume 
// calculation using statistical standard deviation analysis with z-scores.

// R1.30: ALERT ENHANCEMENTS & CODE ORGANIZATION
// =============================================
// Enhanced alert system with comprehensive trade information. Reorganized code structure 
// with consistent spacing for improved readability.

// R1.29: RSI REMOVAL & VOLUME ENHANCEMENT
// =======================================
// Removed RSI functionality to simplify codebase. Enhanced volume display to show status 
// and actual numbers. Reduced table size while maintaining essential information.

// R1.28: ENHANCED TABLE & INTERFACE OPTIMIZATION
// ==============================================
// Added RSI and Volume tracking to risk-reward table with color-coded status indicators. 
// Implemented table toggle functionality and removed unused inputs for cleaner interface.

// R1.0 - R1.27: FOUNDATION & CORE FEATURES
// =========================================
// Evolved from basic swing detection to comprehensive swing trading system. Implemented 
// 7-bar lookback pivot detection, dynamic color-changing breakout lines, persistent 
// profit target/stop loss lines, risk-reward table with live calculations, success 
// rate tracking, and partial profit-taking logic.

// FUTURE REVISIONS (R2.0+)
// ========================
// All future updates will be numbered R2.0 and above, with consolidated change 
// descriptions in paragraph format.

// =============================================================================
// CURRENT VERSION: R1.51 | NEXT VERSION: R2.0
// ============================================================================= 


// Input parameters
lookback = input.int(6, "Lookback Period", minval=1, maxval=50)
show_labels = input.bool(true, "Show Labels")
show_trend_lines = input.bool(true, "Show Trend Lines")


// Risk-Reward Optimization Inputs
show_risk_reward = input.bool(true, "Show Risk-Reward Analysis")
show_table = input.bool(true, "Show Table")
show_stop_targets = input.bool(true, "Show Stop Loss & Take Profit")
light_table_theme = input.bool(false, "Light Table Theme (Toggle for Dark)")



// Technical Indicators Inputs
show_volume = input.bool(true, "Show Volume in Table")
enable_volume_filter = input.bool(true, "Enable Volume Filter for Breakouts")
volume_filter_threshold = input.float(0.5, "Volume Filter Threshold (Z-Score)", minval=-2.0, maxval=2.0, step=0.1, tooltip="Only take breakouts when volume z-score is above this threshold. 0.0 = average volume, 1.0 = high volume, -1.0 = low volume")
show_rsi = input.bool(true, "Show RSI in Table")
rsi_length = input.int(14, "RSI Length", minval=1, maxval=50)

// ATR Settings
atr_length = input.int(14, "ATR Length", minval=1, maxval=50, tooltip="Period for ATR calculation. Default: 14")
atr_stop_multiplier = input.float(1.0, "ATR Stop Loss Multiplier", minval=0.5, maxval=3.0, step=0.1, tooltip="Multiplier for stop loss distance. Default: 1.0 (1 ATR)")
atr_target_multiplier = input.float(2.0, "ATR Profit Target Multiplier", minval=1.0, maxval=5.0, step=0.1, tooltip="Multiplier for profit target distance. Default: 2.0 (2 ATR)")


// Profit Maximization Inputs
enable_partial_taking = input.bool(true, "Enable Partial Profit Taking")
partial_exit_ratio = input.float(0.75, "Partial Exit at R:R Ratio", minval=0.5, maxval=3.0, step=0.1)
partial_exit_size = input.float(60.0, "Partial Exit Size (%)", minval=25.0, maxval=75.0, step=5.0)
enable_trailing_stop = input.bool(true, "Enable Trailing Stop Loss")
trailing_activation_ratio = input.float(0.75, "Trailing Stop Activation (R:R)", minval=0.25, maxval=1.0, step=0.1)
trailing_distance = input.float(0.3, "Trailing Stop Distance (R:R)", minval=0.1, maxval=2.0, step=0.1)


// Variables to store swing points
var float swing_high = na
var float swing_low = na
var int swing_high_bar = na
var int swing_low_bar = na


// Variables to store the most recent swing points (these will persist)
var float most_recent_high = na
var float most_recent_low = na


// Arrays to store historical swing points
var array<float> swing_highs = array.new<float>()
var array<float> swing_lows = array.new<float>()
var array<int> swing_high_bars = array.new<int>()
var array<int> swing_low_bars = array.new<int>()


// Variables to track horizontal lines
var line high_line = na
var line low_line = na


// Variables to track labels
var label high_label = na
var label low_label = na


// Variables to track breakout states
var bool high_breached = false
var bool low_breached = false


// Risk-Reward Optimization Variables
var float entry_price = na
var float stop_loss = na
var float take_profit = na
var float risk_amount = na
var float risk_reward_ratio = na
var string trade_signal = na
var bool new_setup_triggered = false


// Variables to track persistent profit target lines
var line profit_target_line = na
var float last_take_profit = na
var string last_trade_signal = na
var label pt_label = na


// Variables to track persistent stop loss lines
var line stop_loss_line = na
var float last_stop_loss = na
var label sl_label = na
var int setup_bar = na


// Variables to track persistent partial exit level
var float persistent_partial_exit_level = na

// Variables to track profit target hits for visual documentation
var bool profit_target_hit_this_bar = false
var int profit_target_hit_bar = na
var float profit_target_hit_price = na
var string profit_target_hit_signal = na

// Variables to track profit target hit visual elements for cleanup
var line profit_target_hit_line = na
var label profit_target_hit_label = na

// Variables to track stop loss hit visual elements for cleanup
var line stop_loss_hit_line = na
var label stop_loss_hit_label = na

// Variables to track stop loss hits for visual documentation
var bool stop_loss_hit_this_bar = false
var int stop_loss_hit_bar = na
var float stop_loss_hit_price = na
var string stop_loss_hit_signal = na

// Variables to track trailing stop hit visual elements for cleanup
var line trailing_stop_hit_line = na
var label trailing_stop_hit_label = na

// Variables to track trailing stop hits for visual documentation
var bool trailing_stop_hit_this_bar = false
var int trailing_stop_hit_bar = na
var float trailing_stop_hit_price = na
var string trailing_stop_hit_signal = na





// Success Rate Tracking Variables
var int total_breaches = 0
var int successful_trades = 0
var int failed_trades = 0
var int partial_successes = 0
var float total_profit_achieved = 0.0
var float total_risk_taken = 0.0
var float total_profits = 0.0
var float total_losses = 0.0
var bool current_trade_active = false
var float max_pips_beyond_breakout = 0.0
var float last_entry_price = na
var float persistent_entry_price = na
var float trade_profit_achieved = 0.0
var float trade_risk_taken = 0.0


// Profit Maximization Variables
var bool partial_taken = false
var bool trailing_activated = false
var float trailing_stop_level = na
var float partial_exit_level = na
var float remaining_position_size = 100.0

// Alert Tracking Variables for Table Synchronization
var string alert_fired_signal = na
var float alert_fired_entry_price = na
var float alert_fired_take_profit = na
var float alert_fired_stop_loss = na

// Persistent Display Variables for HUD
var string last_display_signal = na
var float last_display_entry = na
var float last_display_take_profit = na
var float last_display_stop_loss = na


// Detect swing high
is_swing_high = ta.pivothigh(high, lookback, lookback)
if not na(is_swing_high)
    swing_high := is_swing_high
    swing_high_bar := bar_index - lookback
    most_recent_high := is_swing_high  // Update the most recent high
    
    // Clear alert-fired variables for new swing high
    alert_fired_signal := na
    alert_fired_entry_price := na
    alert_fired_take_profit := na
    alert_fired_stop_loss := na
    
    array.push(swing_highs, swing_high)
    array.push(swing_high_bars, swing_high_bar)
    
    // Keep only last 5 swing highs
    if array.size(swing_highs) > 5
        array.shift(swing_highs)
        array.shift(swing_high_bars)


// Detect swing low
is_swing_low = ta.pivotlow(low, lookback, lookback)
if not na(is_swing_low)
    swing_low := is_swing_low
    swing_low_bar := bar_index - lookback
    most_recent_low := is_swing_low  // Update the most recent low
    
    // Clear alert-fired variables for new swing low
    alert_fired_signal := na
    alert_fired_entry_price := na
    alert_fired_take_profit := na
    alert_fired_stop_loss := na
    
    array.push(swing_lows, swing_low)
    array.push(swing_low_bars, swing_low_bar)
    
    // Keep only last 5 swing lows
    if array.size(swing_lows) > 5
        array.shift(swing_lows)
        array.shift(swing_low_bars)


// Analyze patterns
var string trend_status = "Sideways"

// Check for higher highs and higher lows (uptrend)
if array.size(swing_highs) >= 2 and array.size(swing_lows) >= 2
    last_high = array.get(swing_highs, array.size(swing_highs) - 1)
    prev_high = array.get(swing_highs, array.size(swing_highs) - 2)
    last_low = array.get(swing_lows, array.size(swing_lows) - 1)
    prev_low = array.get(swing_lows, array.size(swing_lows) - 2)
    
    if last_high > prev_high and last_low > prev_low
        trend_status := "↗️"
    else if last_high < prev_high and last_low < prev_low
        trend_status := "↘️"
    else
        trend_status := "↔️"


// Risk-Reward Optimization Logic - Only calculate on new breaches
if show_risk_reward and not na(most_recent_high) and not na(most_recent_low)
    // Calculate potential entry points
    current_price = close
    
    // Volume calculation for filtering - improved validation
    float avg_volume = ta.sma(volume, 20)
    float vol_std = ta.stdev(volume, 20)
    float volume_z_score = vol_std > 0 ? (volume - avg_volume) / vol_std : 0.0
    bool volume_filter_passed = not enable_volume_filter or (enable_volume_filter and not na(volume_z_score) and not na(volume_filter_threshold) and volume_z_score >= volume_filter_threshold)
    
    // Check for new breaches - any breach should trigger new lines
    bool new_long_breach = close > most_recent_high and close[1] <= most_recent_high and (na(entry_price) or trade_signal != "LONG") and volume_filter_passed
    bool new_short_breach = close < most_recent_low and close[1] >= most_recent_low and (na(entry_price) or trade_signal != "SHORT") and volume_filter_passed
    
    // Set flag for any new breach regardless of direction
    if new_long_breach or new_short_breach
        new_setup_triggered := true
        total_breaches := total_breaches + 1
        
        // If there was an active trade and a new breach occurs, the previous trade failed
        if current_trade_active
            current_trade_active := false
        
        current_trade_active := true
        max_pips_beyond_breakout := 0.0
        trade_profit_achieved := 0.0
        trade_risk_taken := 0.0
        persistent_partial_exit_level := na
    
    // Long setup: Price breaks above swing high (breakout) - only on new breach
    if new_long_breach
        entry_price := most_recent_high  // Use the breakout level as entry
        // Use ATR-based stop loss and profit target
        atr_value = ta.atr(atr_length)
        stop_loss := entry_price - (atr_value * atr_stop_multiplier)  // ATR-based stop loss
        risk_amount := entry_price - stop_loss
        // Set profit target using ATR-based calculation
        take_profit := entry_price + (atr_value * atr_target_multiplier)  // ATR-based profit target
        
        // Only calculate R:R ratio if risk_amount is valid and not zero
        if risk_amount > 0
            risk_reward_ratio := (take_profit - entry_price) / risk_amount
        else
            risk_reward_ratio := na
            
        trade_signal := "LONG"
        
        // Update persistent display variables for long signal
        last_display_signal := "LONG"
        last_display_entry := entry_price
        last_display_take_profit := take_profit
        last_display_stop_loss := stop_loss
        
        // Initialize max tracking for long trades
        max_pips_beyond_breakout := entry_price
        last_entry_price := entry_price
        persistent_entry_price := entry_price
        
        // Calculate partial exit level for profit maximization
        if enable_partial_taking
            partial_exit_level := entry_price + (take_profit - entry_price) * partial_exit_ratio
            persistent_partial_exit_level := partial_exit_level
            partial_taken := false
            remaining_position_size := 100.0
        
        // Initialize trailing stop
        if enable_trailing_stop
            trailing_activated := false
            trailing_stop_level := na
        
    // Short setup: Price breaks below swing low (breakdown) - only on new breach
    else if new_short_breach
        entry_price := most_recent_low  // Use the breakout level as entry
        // Use ATR-based stop loss and profit target
        atr_value = ta.atr(atr_length)
        stop_loss := entry_price + (atr_value * atr_stop_multiplier)  // ATR-based stop loss
        risk_amount := stop_loss - entry_price
        // Set profit target using ATR-based calculation
        take_profit := entry_price - (atr_value * atr_target_multiplier)  // ATR-based profit target
        
        // Only calculate R:R ratio if risk_amount is valid and not zero
        if risk_amount > 0
            risk_reward_ratio := (entry_price - take_profit) / risk_amount
        else
            risk_reward_ratio := na
            
        trade_signal := "SHORT"
        
        // Update persistent display variables for short signal
        last_display_signal := "SHORT"
        last_display_entry := entry_price
        last_display_take_profit := take_profit
        last_display_stop_loss := stop_loss
        
        // Initialize max tracking for short trades
        max_pips_beyond_breakout := entry_price
        last_entry_price := entry_price
        persistent_entry_price := entry_price
        
        // Calculate partial exit level for profit maximization
        if enable_partial_taking
            partial_exit_level := entry_price - (entry_price - take_profit) * partial_exit_ratio
            persistent_partial_exit_level := partial_exit_level
            partial_taken := false
            remaining_position_size := 100.0
        
        // Initialize trailing stop
        if enable_trailing_stop
            trailing_activated := false
            trailing_stop_level := na
        
    else
        // No valid setup
        entry_price := na
        stop_loss := na
        take_profit := na
        risk_amount := na
        risk_reward_ratio := na
        trade_signal := na


// Track maximum price movement beyond breakout for active trades
if current_trade_active and not na(entry_price)
    if last_trade_signal == "LONG"
        max_pips_beyond_breakout := math.max(max_pips_beyond_breakout, high)
    else if last_trade_signal == "SHORT"
        max_pips_beyond_breakout := math.min(max_pips_beyond_breakout, low)


// Profit Maximization Logic - Partial Profit Taking and Trailing Stop
if current_trade_active and not na(last_entry_price) and not na(persistent_partial_exit_level)
    // Check for partial profit taking
    if enable_partial_taking and not partial_taken
        if (last_trade_signal == "LONG" and close >= persistent_partial_exit_level) or (last_trade_signal == "SHORT" and close <= persistent_partial_exit_level)
            partial_taken := true
            remaining_position_size := 100.0 - partial_exit_size
            
            // Calculate partial profit achieved
            if last_trade_signal == "LONG"
                trade_profit_achieved := (persistent_partial_exit_level - last_entry_price) * (partial_exit_size / 100.0)
                trade_risk_taken := (last_entry_price - last_stop_loss) * (partial_exit_size / 100.0)
            else if last_trade_signal == "SHORT"
                trade_profit_achieved := (last_entry_price - persistent_partial_exit_level) * (partial_exit_size / 100.0)
                trade_risk_taken := (last_stop_loss - last_entry_price) * (partial_exit_size / 100.0)
            
            // Track partial success
            partial_successes := partial_successes + 1
            total_profit_achieved := total_profit_achieved + trade_profit_achieved
            total_risk_taken := total_risk_taken + trade_risk_taken
    
    // Check for trailing stop activation
    if enable_trailing_stop and not trailing_activated
        float current_rr = 0.0
        if last_trade_signal == "LONG"
            current_rr := (close - last_entry_price) / (last_entry_price - last_stop_loss)
        else if last_trade_signal == "SHORT"
            current_rr := (last_entry_price - close) / (last_stop_loss - last_entry_price)
        
        if current_rr >= trailing_activation_ratio
            trailing_activated := true
            if last_trade_signal == "LONG"
                trailing_stop_level := close - (last_entry_price - last_stop_loss) * trailing_distance
            else if last_trade_signal == "SHORT"
                trailing_stop_level := close + (last_stop_loss - last_entry_price) * trailing_distance
            
            // Change stop loss line color to indicate trailing stop is active
            if show_risk_reward and show_stop_targets and not na(stop_loss_line)
                line.set_color(stop_loss_line, color.orange)  // Orange color for trailing stop
                label.set_color(sl_label, color.orange)
                label.set_text(sl_label, "TS " + str.tostring(trailing_stop_level, "#.#####"))  // Change label to "TS" with price for Trailing Stop
    
    // Update trailing stop level
    if trailing_activated and not na(trailing_stop_level)
        if last_trade_signal == "LONG"
            trailing_stop_level := math.max(trailing_stop_level, close - (last_entry_price - last_stop_loss) * trailing_distance)
        else if last_trade_signal == "SHORT"
            trailing_stop_level := math.min(trailing_stop_level, close + (last_stop_loss - last_entry_price) * trailing_distance)
        
        // Update stop loss line position to follow trailing stop
        if show_risk_reward and show_stop_targets and not na(stop_loss_line) and not na(setup_bar)
            line.set_xy2(stop_loss_line, setup_bar + 50, trailing_stop_level)
            line.set_xy1(stop_loss_line, setup_bar - 10, trailing_stop_level)
            label.set_xy(sl_label, setup_bar + 55, trailing_stop_level)


// Breach Detection Logic - Always run regardless of label display
if not na(most_recent_high)
    high_breached := close > most_recent_high

if not na(most_recent_low)
    low_breached := close < most_recent_low


// Create horizontal lines with labels for swing points (only if show_labels is enabled)
if not na(swing_high) and show_labels
    line.delete(high_line)
    // Change color if price has closed above the line
    line_color = high_breached ? color.lime : color.teal
    high_line := line.new(swing_high_bar, swing_high, bar_index + 20, swing_high, color=line_color, width=2, style=line.style_solid)
    label.delete(high_label)
    // Add price to the label text
    label_text = trend_status + " " + str.tostring(swing_high, "#.#####")
    high_label := label.new(bar_index + 5, swing_high, label_text, color=line_color, style=label.style_label_left, textcolor=color.white, size=size.normal)

if not na(swing_low) and show_labels
    line.delete(low_line)
    // Change color if price has closed below the line
    line_color = low_breached ? color.rgb(255, 20, 147) : color.gray
    low_line := line.new(swing_low_bar, swing_low, bar_index + 20, swing_low, color=line_color, width=2, style=line.style_solid)
    label.delete(low_label)
    // Add price to the label text
    label_text = trend_status + " " + str.tostring(swing_low, "#.#####")
    low_label := label.new(bar_index + 5, swing_low, label_text, color=line_color, style=label.style_label_left, textcolor=color.white, size=size.normal)


// Draw trend lines
if show_trend_lines and array.size(swing_highs) >= 2 and array.size(swing_lows) >= 2
    // High trend line
    high1_bar = array.get(swing_high_bars, array.size(swing_high_bars) - 2)
    high1_price = array.get(swing_highs, array.size(swing_highs) - 2)
    high2_bar = array.get(swing_high_bars, array.size(swing_high_bars) - 1)
    high2_price = array.get(swing_highs, array.size(swing_highs) - 1)
    
    line.new(high1_bar, high1_price, high2_bar, high2_price, color=color.teal, width=2)
    
    // Low trend line
    low1_bar = array.get(swing_low_bars, array.size(swing_low_bars) - 2)
    low1_price = array.get(swing_lows, array.size(swing_lows) - 2)
    low2_bar = array.get(swing_low_bars, array.size(swing_low_bars) - 1)
    low2_price = array.get(swing_lows, array.size(swing_lows) - 1)
    
    line.new(low1_bar, low1_price, low2_bar, low2_price, color=color.gray, width=2)


// Plot Risk-Reward Analysis - Create lines whenever a new breach occurs
if show_risk_reward and show_stop_targets and new_setup_triggered
    // Delete previous profit target line if it exists
    line.delete(profit_target_line)
    
    // Store the current take profit and signal for persistence
    last_take_profit := take_profit
    last_trade_signal := trade_signal
    
    // Store stop loss for persistence
    last_stop_loss := stop_loss
    
    // Store the bar index when setup was created
    setup_bar := bar_index
    
    // Create new persistent profit target line with fixed positions
    profit_target_line := line.new(setup_bar - 10, take_profit, setup_bar + 50, take_profit, color=color.lime, width=2, style=line.style_dashed)
    
    // Add "PT" label to the profit target line with price
    label.delete(pt_label)
    pt_label_text = "PT " + str.tostring(take_profit, "#.#####")
    pt_label := label.new(setup_bar + 55, take_profit, pt_label_text, color=color.rgb(0, 200, 0), style=label.style_label_left, textcolor=color.white, size=size.small)
    
    // Create stop loss line with fixed positions
    line.delete(stop_loss_line)
    stop_loss_line := line.new(setup_bar - 10, stop_loss, setup_bar + 50, stop_loss, color=color.rgb(220, 0, 0), width=2, style=line.style_dashed)
    
    // Add "SL" label to the stop loss line with price
    label.delete(sl_label)
    sl_label_text = "SL " + str.tostring(stop_loss, "#.#####")
    sl_label := label.new(setup_bar + 55, stop_loss, sl_label_text, color=color.rgb(220, 0, 0), style=label.style_label_left, textcolor=color.white, size=size.small)
    
    // Reset the flag after lines are created
    new_setup_triggered := false


// Show persistent profit target line if no new setup but we have a previous one
if show_risk_reward and show_stop_targets and not new_setup_triggered and not na(last_take_profit)
    // Check if price has crossed the profit target or trailing stop
    bool profit_target_hit = (last_trade_signal == "LONG" and close >= last_take_profit) or (last_trade_signal == "SHORT" and close <= last_take_profit)
    bool trailing_stop_hit = trailing_activated and not na(trailing_stop_level) and ((last_trade_signal == "LONG" and close <= trailing_stop_level) or (last_trade_signal == "SHORT" and close >= trailing_stop_level))
    
    // Check if price has crossed back over the original swing line (invalidates the breakout)
    bool swing_line_crossed_back = false
    if last_trade_signal == "LONG" and not na(most_recent_high)
        swing_line_crossed_back := close < most_recent_high and close[1] >= most_recent_high
    else if last_trade_signal == "SHORT" and not na(most_recent_low)
        swing_line_crossed_back := close > most_recent_low and close[1] <= most_recent_low
    
    // Track profit target hits for visual documentation
    if profit_target_hit and not profit_target_hit_this_bar
        // Clean up previous profit target hit visual elements
        line.delete(profit_target_hit_line)
        label.delete(profit_target_hit_label)
        
        profit_target_hit_this_bar := true
        profit_target_hit_bar := bar_index
        profit_target_hit_price := close
        profit_target_hit_signal := last_trade_signal
    else if profit_target_hit_this_bar and bar_index > profit_target_hit_bar
        // Reset the flag after the bar where the hit occurred
        profit_target_hit_this_bar := false
    
    // Track stop loss hits for visual documentation
    bool stop_loss_hit = trailing_activated and not na(trailing_stop_level) and ((last_trade_signal == "LONG" and close <= trailing_stop_level) or (last_trade_signal == "SHORT" and close >= trailing_stop_level))
    
    if stop_loss_hit and not stop_loss_hit_this_bar
        // Clean up previous stop loss hit visual elements
        line.delete(stop_loss_hit_line)
        label.delete(stop_loss_hit_label)
        
        stop_loss_hit_this_bar := true
        stop_loss_hit_bar := bar_index
        stop_loss_hit_price := close
        stop_loss_hit_signal := last_trade_signal
    else if stop_loss_hit_this_bar and bar_index > stop_loss_hit_bar
        // Reset the flag after the bar where the hit occurred
        stop_loss_hit_this_bar := false
    
    // Track trailing stop hits for visual documentation
    bool trailing_stop_triggered = trailing_activated and not na(trailing_stop_level) and ((last_trade_signal == "LONG" and close <= trailing_stop_level) or (last_trade_signal == "SHORT" and close >= trailing_stop_level))
    
    if trailing_stop_triggered and not trailing_stop_hit_this_bar
        // Clean up previous trailing stop hit visual elements
        line.delete(trailing_stop_hit_line)
        label.delete(trailing_stop_hit_label)
        
        trailing_stop_hit_this_bar := true
        trailing_stop_hit_bar := bar_index
        trailing_stop_hit_price := close
        trailing_stop_hit_signal := last_trade_signal
    else if trailing_stop_hit_this_bar and bar_index > trailing_stop_hit_bar
        // Reset the flag after the bar where the hit occurred
        trailing_stop_hit_this_bar := false
    
    if profit_target_hit or stop_loss_hit or trailing_stop_hit or swing_line_crossed_back
        // Price has hit the profit target, stop loss, trailing stop, or crossed back over swing line
        line.delete(profit_target_line)
        label.delete(pt_label)
        line.delete(stop_loss_line)
        label.delete(sl_label)
        last_take_profit := na
        last_trade_signal := na
        last_stop_loss := na
        persistent_entry_price := na
        
        // Calculate full profit achieved for remaining position
        if current_trade_active and not na(last_entry_price)
            float full_profit_achieved = 0.0
            float full_risk_taken = 0.0
            
            if profit_target_hit
                if last_trade_signal == "LONG"
                    full_profit_achieved := (last_take_profit - last_entry_price) * (remaining_position_size / 100.0)
                    full_risk_taken := (last_entry_price - last_stop_loss) * (remaining_position_size / 100.0)
                else if last_trade_signal == "SHORT"
                    full_profit_achieved := (last_entry_price - last_take_profit) * (remaining_position_size / 100.0)
                    full_risk_taken := (last_stop_loss - last_entry_price) * (remaining_position_size / 100.0)
            else if stop_loss_hit
                if last_trade_signal == "LONG"
                    full_profit_achieved := 0.0  // Stop loss hit = no profit
                    full_risk_taken := (last_entry_price - last_stop_loss) * (remaining_position_size / 100.0)
                else if last_trade_signal == "SHORT"
                    full_profit_achieved := 0.0  // Stop loss hit = no profit
                    full_risk_taken := (last_stop_loss - last_entry_price) * (remaining_position_size / 100.0)
            else if trailing_stop_hit
                if last_trade_signal == "LONG"
                    full_profit_achieved := (trailing_stop_level - last_entry_price) * (remaining_position_size / 100.0)
                    full_risk_taken := (last_entry_price - last_stop_loss) * (remaining_position_size / 100.0)
                else if last_trade_signal == "SHORT"
                    full_profit_achieved := (last_entry_price - trailing_stop_level) * (remaining_position_size / 100.0)
                    full_risk_taken := (last_stop_loss - last_entry_price) * (remaining_position_size / 100.0)
            
            // Track success/failure and profit/loss based on exit type
            if swing_line_crossed_back
                // Swing line cross-back = failed trade
                failed_trades := failed_trades + 1
                total_losses := total_losses + full_risk_taken  // Full risk taken on failed trade
            else
                // All other exits (profit target, stop loss, trailing stop) = successful trades
                successful_trades := successful_trades + 1
                total_profit_achieved := total_profit_achieved + full_profit_achieved
                total_risk_taken := total_risk_taken + full_risk_taken
                
                // Track profits vs losses for profit factor calculation
                if full_profit_achieved > 0
                    total_profits := total_profits + full_profit_achieved
                else
                    total_losses := total_losses + math.abs(full_profit_achieved)  // Stop loss = loss
            
            current_trade_active := false
            max_pips_beyond_breakout := 0.0
            partial_taken := false
            trailing_activated := false
            trailing_stop_level := na
            partial_exit_level := na
            persistent_partial_exit_level := na


// RSI Calculation (moved before table for faster loading)
float rsi_value = show_rsi ? ta.rsi(close, rsi_length) : na

// Risk-Reward Ratio Table
if show_risk_reward and show_table
    // Theme-based colors
    color table_bg = light_table_theme ? color.white : color.rgb(20, 20, 30)
    color header_bg = light_table_theme ? color.rgb(240, 240, 240) : color.rgb(30, 30, 50)
    color header_text = light_table_theme ? color.rgb(50, 50, 50) : color.rgb(200, 200, 255)
    color success_text = light_table_theme ? color.rgb(0, 150, 0) : color.rgb(0, 255, 150)
    color success_bg = light_table_theme ? color.rgb(220, 255, 220) : color.rgb(0, 50, 25)
    color warning_text = light_table_theme ? color.rgb(200, 0, 0) : color.rgb(255, 100, 100)
    color warning_bg = light_table_theme ? color.rgb(255, 220, 220) : color.rgb(50, 0, 0)
    color info_text = light_table_theme ? color.rgb(150, 100, 0) : color.rgb(255, 200, 100)
    color info_bg = light_table_theme ? color.rgb(255, 250, 220) : color.rgb(50, 30, 0)
    color strategy_text = light_table_theme ? color.rgb(150, 150, 0) : color.rgb(255, 255, 150)
    color strategy_bg = light_table_theme ? color.rgb(255, 255, 220) : color.rgb(50, 50, 0)
    
    var table rr_table = table.new(position.top_right, 2, show_volume ? (enable_volume_filter ? (show_rsi ? 8 : 7) : (show_rsi ? 7 : 6)) : (show_rsi ? 6 : 5), bgcolor=table_bg, border_width=2, border_color=color.rgb(100, 100, 150))
    
    if barstate.islast
        // Spacer row for top margin
        table.cell(rr_table, 0, 0, "", text_color=color.white, bgcolor=color.rgb(20, 20, 30), text_size=size.small)
        table.cell(rr_table, 1, 0, "", text_color=color.white, bgcolor=color.rgb(20, 20, 30), text_size=size.small)
        
        // Header with gradient effect and emojis
        table.cell(rr_table, 0, 1, "🔥 HEADS UP DISPLAY", text_color=color.white, bgcolor=color.rgb(60, 20, 80), text_size=size.large)
        table.cell(rr_table, 1, 1, "HUD 🔥", text_color=color.white, bgcolor=color.rgb(60, 20, 80), text_size=size.large)
        
        // Signal & R:R Ratio combined - Persist until new signal
        float current_rr = na
        string signal_rr_text = "na"
        
        // Use alert_fired values if available, otherwise use persistent display values
        string display_signal = not na(alert_fired_signal) ? alert_fired_signal : last_display_signal
        float display_entry = not na(alert_fired_entry_price) ? alert_fired_entry_price : last_display_entry
        float display_take_profit = not na(alert_fired_take_profit) ? alert_fired_take_profit : last_display_take_profit
        float display_stop_loss = not na(alert_fired_stop_loss) ? alert_fired_stop_loss : last_display_stop_loss
        
        if not na(display_signal) and not na(display_entry) and not na(display_take_profit) and not na(display_stop_loss)
            if display_signal == "LONG"
                current_rr := (display_take_profit - display_entry) / (display_entry - display_stop_loss)
            else if display_signal == "SHORT"
                current_rr := (display_entry - display_take_profit) / (display_stop_loss - display_entry)
        
        signal_rr_text := not na(display_signal) ? display_signal : "na"
        if not na(current_rr) and current_rr > 0
            signal_rr_text := signal_rr_text + " | 1:" + str.tostring(current_rr, "#.##")
        
        table.cell(rr_table, 0, 2, "📈 Signal & R:R", text_color=header_text, bgcolor=header_bg)
        table.cell(rr_table, 1, 2, signal_rr_text, text_color=display_signal == "LONG" ? success_text : warning_text, bgcolor=display_signal == "LONG" ? success_bg : warning_bg)
        

        
        // Entry & Pip Distance combined - Persist until new signal
        float pip_distance = na
        string entry_distance_text = "na"
        
        // Use display values from signal section for consistency
        if not na(display_signal) and not na(display_entry) and not na(display_take_profit)
            if display_signal == "LONG"
                pip_distance := (display_take_profit - display_entry) * 10000  // Convert to pips (4 decimal places)
            else if display_signal == "SHORT"
                pip_distance := (display_entry - display_take_profit) * 10000  // Convert to pips (4 decimal places)
        
        entry_distance_text := not na(display_entry) ? str.tostring(display_entry, "#.#####") : "na"
        if not na(pip_distance)
            entry_distance_text := entry_distance_text + " | " + str.tostring(pip_distance, "#") + "p"
        
        // Add ATR value to the display
        float current_atr = ta.atr(atr_length)
        entry_distance_text := entry_distance_text + " | ATR:" + (not na(current_atr) ? str.tostring(current_atr * 10000, "#") : "na") + "p"
        
        table.cell(rr_table, 0, 3, "🎯 Entry & Distance", text_color=header_text, bgcolor=header_bg)
        table.cell(rr_table, 1, 3, entry_distance_text, text_color=info_text, bgcolor=info_bg)
        
        // Success Rate and Profit Factor calculation - now properly accounts for all exit types
        int total_completed_trades = successful_trades + failed_trades
        float success_rate = total_completed_trades > 0 ? (successful_trades / total_completed_trades) * 100 : 0.0
        float partial_success_rate = total_breaches > 0 ? (partial_successes / total_breaches) * 100 : 0.0
        float profit_factor = total_losses > 0 ? total_profits / total_losses : 0.0
        
        table.cell(rr_table, 0, 4, "🎯 Success Rate/Edge", text_color=header_text, bgcolor=header_bg)
        table.cell(rr_table, 1, 4, str.tostring(success_rate, "#.#") + "% (" + str.tostring(successful_trades) + "/" + str.tostring(total_completed_trades) + ") | PF:" + str.tostring(profit_factor, "#.##"), text_color=success_rate >= 50.0 ? success_text : warning_text, bgcolor=success_rate >= 50.0 ? success_bg : warning_bg)

        // Position & PM Status combined
        string position_pm_text = not na(remaining_position_size) ? str.tostring(remaining_position_size, "#.##") + "%" : "na"
        if not na(partial_taken)
            position_pm_text := position_pm_text + " | P:" + (partial_taken ? "Y" : "N") + " T:" + (trailing_activated ? "Y" : "N")
        
        table.cell(rr_table, 0, 5, "📊 Position & PM", text_color=header_text, bgcolor=header_bg)
        table.cell(rr_table, 1, 5, position_pm_text, text_color=info_text, bgcolor=info_bg)

        // Volume & Filter combined
        if show_volume
            // Volume calculation using standard deviation
            float avg_volume = ta.sma(volume, 20)
            float vol_std = ta.stdev(volume, 20)
            float volume_z_score = vol_std > 0 ? (volume - avg_volume) / vol_std : 0.0
            string volume_status = "Normal"
            color volume_color = light_table_theme ? color.rgb(255, 140, 0) : color.rgb(255, 165, 0)  // Orange color
            
            if not na(volume_z_score)
                if volume_z_score > 1.0
                    volume_status := "High"
                    volume_color := success_text
                else if volume_z_score < -1.0
                    volume_status := "Weak"
                    volume_color := warning_text
                else
                    volume_status := "Normal"
                    volume_color := light_table_theme ? color.rgb(255, 140, 0) : color.rgb(255, 165, 0)  // Orange color
            
            string volume_filter_text = not na(volume_z_score) ? volume_status + " (" + str.tostring(volume, "#") + "K)" : "Loading..."
            
            // Add filter status if enabled
            if enable_volume_filter
                bool volume_filter_active = not na(volume_z_score) and volume_z_score >= volume_filter_threshold
                string filter_status = volume_filter_active ? "✅" : "❌"
                volume_filter_text := volume_filter_text + " | " + filter_status + " [" + str.tostring(volume_filter_threshold, "#.#") + "]"
                volume_color := volume_filter_active ? success_text : warning_text
            
            table.cell(rr_table, 0, 6, "📈 Volume & Filter", text_color=header_text, bgcolor=header_bg)
            table.cell(rr_table, 1, 6, volume_filter_text, text_color=volume_color, bgcolor=info_bg)

        // RSI Information
        if show_rsi
            string rsi_status = "Neutral"
            color rsi_color = light_table_theme ? color.rgb(255, 140, 0) : color.rgb(255, 165, 0)  // Orange color
            
            if not na(rsi_value)
                if rsi_value >= 70
                    rsi_status := "Overbought"
                    rsi_color := light_table_theme ? color.rgb(255, 0, 0) : color.rgb(255, 50, 50)  // Bright red for overbought
                else if rsi_value <= 30
                    rsi_status := "Oversold"
                    rsi_color := light_table_theme ? color.rgb(0, 255, 0) : color.rgb(50, 255, 50)  // Bright green for oversold
                else if rsi_value > 50
                    rsi_status := "Bullish"
                    rsi_color := light_table_theme ? color.rgb(0, 150, 0) : color.rgb(0, 200, 0)  // Darker green for bullish
                else if rsi_value < 50
                    rsi_status := "Bearish"
                    rsi_color := light_table_theme ? color.rgb(150, 0, 0) : color.rgb(200, 0, 0)  // Darker red for bearish
                else
                    rsi_status := "Neutral"
                    rsi_color := light_table_theme ? color.rgb(255, 140, 0) : color.rgb(255, 165, 0)  // Orange color
            
            string rsi_text = not na(rsi_value) ? rsi_status + " (" + str.tostring(rsi_value, "#.#") + ")" : "Loading..."
            
            // Add RSI filter status
            bool rsi_filter_active = not na(rsi_value) and rsi_value < 70 and rsi_value > 30
            string rsi_filter_status = rsi_filter_active ? "✅" : "❌"
            rsi_text := rsi_text + " | " + rsi_filter_status + " [30-70]"
            
            // Set color based on RSI status with trading intuition using different shades
            if not na(rsi_value)
                if rsi_value >= 70
                    rsi_color := light_table_theme ? color.rgb(255, 0, 0) : color.rgb(255, 50, 50)  // Bright red for overbought (think about selling)
                else if rsi_value <= 30
                    rsi_color := light_table_theme ? color.rgb(0, 255, 0) : color.rgb(50, 255, 50)  // Bright green for oversold (think about buying)
                else if rsi_value > 50
                    rsi_color := light_table_theme ? color.rgb(0, 150, 0) : color.rgb(0, 200, 0)  // Darker green for bullish conditions
                else if rsi_value < 50
                    rsi_color := light_table_theme ? color.rgb(150, 0, 0) : color.rgb(200, 0, 0)  // Darker red for bearish conditions
                else
                    rsi_color := info_text  // Orange for neutral conditions
            
            int rsi_row = show_volume ? (enable_volume_filter ? 7 : 6) : 5
            table.cell(rr_table, 0, rsi_row, "📊 RSI & Filter", text_color=header_text, bgcolor=header_bg)
            table.cell(rr_table, 1, rsi_row, rsi_text, text_color=rsi_color, bgcolor=info_bg)


// Breakout Alert Conditions
// Alert when swing high line changes from teal to green (bullish breakout)
if not na(most_recent_high) and close > most_recent_high and close[1] <= most_recent_high
    // Volume calculation for alert filtering - improved validation
    float alert_avg_volume = ta.sma(volume, 20)
    float alert_vol_std = ta.stdev(volume, 20)
    float alert_volume_z_score = alert_vol_std > 0 ? (volume - alert_avg_volume) / alert_vol_std : 0.0
    
    // Enhanced volume filter validation - only pass if threshold is valid and z-score meets requirement
    bool alert_volume_filter_passed = not enable_volume_filter or (enable_volume_filter and not na(alert_volume_z_score) and not na(volume_filter_threshold) and alert_volume_z_score >= volume_filter_threshold)
    
    // RSI filter for long positions - avoid overbought conditions
    bool rsi_filter_passed = not show_rsi or (show_rsi and not na(rsi_value) and rsi_value < 70 and rsi_value > 30)
    
    if alert_volume_filter_passed and rsi_filter_passed
        // Set alert-fired variables for table synchronization
        alert_fired_signal := "LONG"
        alert_fired_entry_price := most_recent_high
        alert_fired_take_profit := most_recent_high + (ta.atr(atr_length) * atr_target_multiplier)
        alert_fired_stop_loss := most_recent_high - (ta.atr(atr_length) * atr_stop_multiplier)
        
        // Store persistent display values
        last_display_signal := "LONG"
        last_display_entry := most_recent_high
        last_display_take_profit := most_recent_high + (ta.atr(atr_length) * atr_target_multiplier)
        last_display_stop_loss := most_recent_high - (ta.atr(atr_length) * atr_stop_multiplier)
        
        alert("BULLISH BREAKOUT on " + syminfo.ticker + " (" + timeframe.period + ") at price " + str.tostring(close, "#.#####") + " | Opposite swing (low): " + str.tostring(most_recent_low, "#.#####") + " (suggested stop loss) | Profit target: " + str.tostring(take_profit, "#.#####") + " - Price closed above swing high" + (enable_volume_filter ? " | Volume Z-Score: " + str.tostring(alert_volume_z_score, "#.##") : "") + (show_rsi ? " | RSI: " + str.tostring(rsi_value, "#.#") : ""), alert.freq_once_per_bar)


// Alert when swing low line changes from gray to red (bearish breakdown)
if not na(most_recent_low) and close < most_recent_low and close[1] >= most_recent_low
    // Volume calculation for alert filtering - improved validation
    float alert_avg_volume = ta.sma(volume, 20)
    float alert_vol_std = ta.stdev(volume, 20)
    float alert_volume_z_score = alert_vol_std > 0 ? (volume - alert_avg_volume) / alert_vol_std : 0.0
    
    // Enhanced volume filter validation - only pass if threshold is valid and z-score meets requirement
    bool alert_volume_filter_passed = not enable_volume_filter or (enable_volume_filter and not na(alert_volume_z_score) and not na(volume_filter_threshold) and alert_volume_z_score >= volume_filter_threshold)
    
    // RSI filter for short positions - avoid oversold conditions
    bool rsi_filter_passed = not show_rsi or (show_rsi and not na(rsi_value) and rsi_value < 70 and rsi_value > 30)
    
    if alert_volume_filter_passed and rsi_filter_passed
        // Set alert-fired variables for table synchronization
        alert_fired_signal := "SHORT"
        alert_fired_entry_price := most_recent_low
        alert_fired_take_profit := most_recent_low - (ta.atr(atr_length) * atr_target_multiplier)
        alert_fired_stop_loss := most_recent_low + (ta.atr(atr_length) * atr_stop_multiplier)
        
        // Store persistent display values
        last_display_signal := "SHORT"
        last_display_entry := most_recent_low
        last_display_take_profit := most_recent_low - (ta.atr(atr_length) * atr_target_multiplier)
        last_display_stop_loss := most_recent_low + (ta.atr(atr_length) * atr_stop_multiplier)
        
        alert("BEARISH BREAKDOWN on " + syminfo.ticker + " (" + timeframe.period + ") at price " + str.tostring(close, "#.#####") + " | Opposite swing (high): " + str.tostring(most_recent_high, "#.#####") + " (suggested stop loss) | Profit target: " + str.tostring(take_profit, "#.#####") + " - Price closed below swing low" + (enable_volume_filter ? " | Volume Z-Score: " + str.tostring(alert_volume_z_score, "#.##") : "") + (show_rsi ? " | RSI: " + str.tostring(rsi_value, "#.#") : ""), alert.freq_once_per_bar)


// Trailing Stop Alert
if enable_trailing_stop and trailing_activated and not trailing_activated[1]
    alert("TRAILING STOP ACTIVATED on " + syminfo.ticker + " (" + timeframe.period + ") at price " + str.tostring(close, "#.#####") + " - Stop loss moved to " + str.tostring(trailing_stop_level, "#.#####") + ". According to the indicator's strategy, this is a suggested point to close 50% (half) of your position.", alert.freq_once_per_bar)







// RSI Series Detection - Option 2 Implementation
// Track consecutive dots and use different colors for first vs last dot in series
var int consecutive_overbought = 0
var int consecutive_oversold = 0

// Count consecutive overbought dots
if show_rsi and not na(rsi_value) and rsi_value >= 70
    consecutive_overbought := consecutive_overbought + 1
else
    consecutive_overbought := 0

// Track previous overbought state to detect series end
var bool was_overbought = false
bool is_overbought = show_rsi and not na(rsi_value) and rsi_value >= 70
bool overbought_series_ended = was_overbought and not is_overbought
was_overbought := is_overbought

// Count consecutive oversold dots  
if show_rsi and not na(rsi_value) and rsi_value <= 30
    consecutive_oversold := consecutive_oversold + 1
else
    consecutive_oversold := 0

// Track previous oversold state to detect series end
var bool was_oversold = false
bool is_oversold = show_rsi and not na(rsi_value) and rsi_value <= 30
bool oversold_series_ended = was_oversold and not is_oversold
was_oversold := is_oversold

// Plot dots with different colors for series vs last dot
plotshape(show_rsi and not na(rsi_value) and rsi_value >= 70 and consecutive_overbought > 1, title="Overbought Series", location=location.abovebar, color=color.red, style=shape.circle, size=size.tiny)
plotshape(overbought_series_ended, title="Last Overbought", location=location.abovebar, color=color.yellow, style=shape.circle, size=size.small)
plotshape(show_rsi and not na(rsi_value) and rsi_value <= 30 and consecutive_oversold > 1, title="Oversold Series", location=location.belowbar, color=color.green, style=shape.circle, size=size.tiny)
plotshape(oversold_series_ended, title="Last Oversold", location=location.belowbar, color=color.orange, style=shape.circle, size=size.small)


// RSI Large Dot Alerts
// Alert for yellow dot (Last Overbought) - RSI overbought series ended
if show_rsi and overbought_series_ended
    alert("RSI OVERBOUGHT SERIES ENDED on " + syminfo.ticker + " (" + timeframe.period + ") at price " + str.tostring(close, "#.#####") + " | RSI: " + str.tostring(rsi_value, "#.#") + " - Yellow dot indicates potential reversal from overbought conditions. Consider looking for short opportunities or closing long positions.", alert.freq_once_per_bar)

// Alert for orange dot (Last Oversold) - RSI oversold series ended  
if show_rsi and oversold_series_ended
    alert("RSI OVERSOLD SERIES ENDED on " + syminfo.ticker + " (" + timeframe.period + ") at price " + str.tostring(close, "#.#####") + " | RSI: " + str.tostring(rsi_value, "#.#") + " - Orange dot indicates potential reversal from oversold conditions. Consider looking for long opportunities or closing short positions.", alert.freq_once_per_bar)


// =============================================================================
// PROFIT TARGET HIT VISUAL DOCUMENTATION
// =============================================================================

// Profit target hit documentation handled in conditional block below

// Handle profit target hit documentation
if profit_target_hit_this_bar and not na(profit_target_hit_bar)
    // Create a horizontal line extending from the hit point
    line_color = profit_target_hit_signal == "LONG" ? color.rgb(0, 255, 0) : color.rgb(255, 0, 255)
    profit_target_hit_line := line.new(profit_target_hit_bar, profit_target_hit_price, profit_target_hit_bar + 20, profit_target_hit_price, color=line_color, width=3, style=line.style_solid)
    
    // Add a label with profit target hit information
    label_color = profit_target_hit_signal == "LONG" ? color.rgb(0, 255, 0) : color.rgb(255, 0, 255)
    text_color = profit_target_hit_signal == "LONG" ? color.black : color.black
    profit_target_hit_label := label.new(profit_target_hit_bar + 25, profit_target_hit_price, "PROFIT TARGET HIT\n" + profit_target_hit_signal + " @ " + str.tostring(profit_target_hit_price, "#.#####"), color=label_color, style=label.style_label_left, textcolor=text_color, size=size.small)
    
    // Reset the flag after documenting
    profit_target_hit_this_bar := false


// =============================================================================
// STOP LOSS HIT VISUAL DOCUMENTATION
// =============================================================================

// Handle stop loss hit documentation
if stop_loss_hit_this_bar and not na(stop_loss_hit_bar)
    // Create a horizontal line extending from the hit point
    line_color = color.rgb(220, 0, 0)  // Red for stop loss hits
    stop_loss_hit_line := line.new(stop_loss_hit_bar, stop_loss_hit_price, stop_loss_hit_bar + 20, stop_loss_hit_price, color=line_color, width=3, style=line.style_solid)
    
    // Add a label with stop loss hit information
    label_color = color.rgb(220, 0, 0)  // Red for stop loss hits
    text_color = color.black
    stop_loss_hit_label := label.new(stop_loss_hit_bar + 25, stop_loss_hit_price, "STOP LOSS HIT\n" + stop_loss_hit_signal + " @ " + str.tostring(stop_loss_hit_price, "#.#####"), color=label_color, style=label.style_label_left, textcolor=text_color, size=size.small)
    
    // Reset the flag after documenting
    stop_loss_hit_this_bar := false


// =============================================================================
// TRAILING STOP HIT VISUAL DOCUMENTATION
// =============================================================================

// Handle trailing stop hit documentation
if trailing_stop_hit_this_bar and not na(trailing_stop_hit_bar)
    // Create a horizontal line extending from the hit point
    line_color = color.rgb(255, 165, 0)  // Orange for trailing stop hits
    trailing_stop_hit_line := line.new(trailing_stop_hit_bar, trailing_stop_hit_price, trailing_stop_hit_bar + 20, trailing_stop_hit_price, color=line_color, width=3, style=line.style_solid)
    
    // Add a label with trailing stop hit information
    label_color = color.rgb(255, 165, 0)  // Orange for trailing stop hits
    text_color = color.black
    trailing_stop_hit_label := label.new(trailing_stop_hit_bar + 25, trailing_stop_hit_price, "TRAILING STOP HIT\n" + trailing_stop_hit_signal + " @ " + str.tostring(trailing_stop_hit_price, "#.#####"), color=label_color, style=label.style_label_left, textcolor=text_color, size=size.small)
    
    // Reset the flag after documenting
    trailing_stop_hit_this_bar := false